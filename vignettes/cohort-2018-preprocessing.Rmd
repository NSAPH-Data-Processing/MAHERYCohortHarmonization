---
title: "Cohort 2018 Preprocessing"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Cohort 2018 Preprocessing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r}
library(MAHERYCohortHarmonization)
```

<!-- WARNING - This vignette is generated by {fusen} from dev/flat_preprocess_2018.Rmd: do not edit by hand -->




# preprocess_2018

In this notebook, we're exploring and preprocessing the 2018 data from OpenSRP.
The function will ultimately preprocess the data so that it can be harmonized
effectively with the other datasets. Importantly, we use the column suffix `_clean`
to denote that the column has been cleaned and is being kept for analysis.

What is OpenSRP?

What is OpenSRP? It appears OpenSRP should cover year 2018. What is it and what does it survey?
> Open SRP is a software to collect data. We collaborated with an Indonesian-based researchin 2018 that managed and stored our data. Their website does not exist anymore. That is the first platform we used for the ongoing health surveillance surveys. The data is stored in a flat file format. We are working on a new platform to collect data, but we are not there yet. The data is stored in a flat file format. We are working on a new platform to collect data, but we are not there yet.

Load the targets data for prototyping:

The OpenSRP file has a number of sheets:
```{r}
library(targets)
tar_load(opensrp)
tar_load(opensrp_dict)

library(here)
library(dplyr)
library(stringr)
library(janitor)
library(targets)
library(skimr)
library(forcats)
library(lubridate)
library(googledrive)
library(ggplot2)
library(ggalluvial)
```


Importantly, there are a few "hierarchical levels" of data catalogued here.

Level 0: Household enrollment
Level 1: Individuals in household
Level 2: Antropometric data (every 3 months), dietary intake data collected from head of household (every 4 months), followup data

Although, for clarity, this should be named the opposite...?

Ultimately, a good idea might be to have it such that the most granular
level is an individual, the next level up is their household. But we can solve for that later.

### audit_categorical_cleaning

A function for plotting the mapping of categorical variables from raw to clean, see `audit_categorical_cleaning()`.
    
  
  
  

## Open Census

We're told that the Open census sheet is the baseline. This should be
the most granular level of individual data.
```{r}
open_census <- opensrp$`Open census`
```


```{r}
summary(open_census)
```


```{r}
skimr::skim(open_census)
```


We'll start by using janitor to clean the column names.
```{r}
open_census_ <- janitor::clean_names(open_census)
```


What is user ID?
```{r}
open_census_ %>%
  pull(user_id) %>%
  unique() %>% length()
```


We only have two unique values for this. The values themselves are just a region
in Madagascar. So we can leave this column as a factor.
```{r}
open_census_ %>%
  mutate(user_id_clean = as_factor(user_id)) -> open_census_
```


Next, `hh_head_name`. This is supposedly the name of the head of household.
```{r}
open_census_ %>%
  pull(hh_head_name) %>%
  unique() %>% length()
```


We have 134 unique HHs. But, we can see that there are some
weird anomalies here. For example, some entries have commas and
extra spaces. We can clean this up with `str_squish` and `str_remove_all`.
```{r}
open_census_ %>%
  mutate(hh_head_name_clean = hh_head_name %>%
    str_to_lower() %>%
    str_squish() %>%
    str_remove_all(",")
  ) -> open_census_
```


```{r}
open_census_ %>%
  pull(hh_head_name_clean) %>%
  unique() %>% length()
```


The number of unique entries stays the same, so this is encouraging.

Next, we look at the `name_family_member` column. This is the name of the household member, ideally the most granular observation in the dataset.
```{r}
open_census_ %>%
  pull(name_family_member) %>%
  unique() %>% length()
```


Some must be duplicated, so let's find those:
```{r}
open_census_ %>%
  group_by(name_family_member, hh_head_name) %>%
  summarise(n = n()) %>%
  filter(n > 1) %>%
  arrange(desc(n)) -> dups

open_census_ %>%
  filter(name_family_member %in% dups$name_family_member) %>% arrange(name_family_member) -> multi_names
```


There are a number of people who are listed as the same name, but
with different IDs or member codes. We'll have to keep an eye on these.
What we can probably do is code all of the other columns and check for anomalies
there.
```{r}
open_census_ %>%
  mutate(name_family_member_clean = name_family_member %>%
    str_to_lower() %>%
    str_squish() %>%
    str_remove_all(",")
  ) -> open_census_
```


### DoB

Next is date of birth. This is coded pretty weird, but we have
a column called `dob_actual` which might tell us if it is a valid
DoB row.

We should check to make sure that everyone has at least one `yes` to this column:
```{r}
open_census_ %>%
  filter(dob_actual == "Yes") %>%
  pull(name_family_member) %>%
  unique() %>% length()
```


So there are some people who do not have a DoB actual.
Let's do our best to form DoBs from the columns anyway, and see
how that goes. Importantly, there are cases where the
month is coded as 'month idr'. Here's a chatgpt response to that:

> This abbreviation may have been derived from “I don’t remember” in English, either directly or influenced by informal bilingual usage, especially in multilingual communities where French and some English are spoken.

I think we can safely assume that this is the case, and
as long as the year is valid, we can make an assumption and place
their DoB as January 1st of that year (we'll flag these though as `dob_estimated`).

Below is the function that makes our DoBs:
  
  
  
Let's see the effect of this mutation:
```{r}
open_census_ %>%
  clean_opencensus_dob() -> open_census_
```


We lose 7 rows in the process. 
```{r}
open_census_ %>%
      filter(is.na(dob_clean))
```


One of them is coded as a leap year in 1997 (impossible). What's interesting is that the `dob_actual` value is "Yes", so this is definitely strange.
Four of them have 999 (NA) as their year, so we can't do anything about that.
The remaining 2 have NA in the month, so we cannot use them.
```{r}
open_census_ %>%
  select(dob_actual, dob_estimated) %>%
  table()
```


There were 54 cases where DoB was estimated but the original column
said that it was actual. I wonder how these got encoded that way then?
```{r}
open_census_ %>%
  filter(dob_actual == "Yes" & dob_estimated == TRUE)
```


What is the distribution of DoB?
```{r}
library(ggplot2)
min_year <- min(open_census_$dob_clean,na.rm = T) %>% year()
max_year <- max(open_census_$dob_clean,na.rm = T) %>% year()
open_census_ %>%
  ggplot(aes(x = dob_clean)) +
  geom_histogram(bins = length(min_year:max_year)) + # one bin per year
  scale_x_date(date_labels = "%Y") +
  ggtitle("Distribution of Date of Birth binned by Year")
```


We can move on with the other variables.

## Open Census — Demographics Cont'd

We can process ethnic group next:
```{r}
open_census_$ethnic_group %>% table()
```


```{r}
open_census_$other_ethnic_group %>% table()
```


I think we can collapse these into a single column.
```{r}
open_census_ %>%
  mutate(ethnicity_clean =
    case_when(
      is.na(ethnic_group)     ~ other_ethnic_group,
      ethnic_group == "Ethnic group other" ~ other_ethnic_group,
      .default = ethnic_group
    ) %>% str_to_lower() %>% as_factor()
  ) -> open_census_
```


```{r}
open_census_$ethnicity %>% table()
```


### Education & Profession

The recoding of education is done like so:
      
    

```{r}
open_census_ %>%
  recode_opensrp_education() -> open_census_
```


```{r}
open_census_$education_level_clean %>% table()
```


I think we can comfortably collapse profession
```{r}
open_census_ %>% 
  select(matches('^profession*')) %>%
  table()
```


We can classify employment with the following:

> “Employment status is classified following ILO and DHIS2 recommendations: distinguishing Employed, Unemployed, Inactive (students, homemakers, retirees, disabled), Not applicable (persons below minimum working age), and Unknown.”

We have a column `other_profession` which currently only only has two
outstanding entries: `commitionaire` and `Zaza loatra tsy miasa`. The latter
means "too young," and the former likely means "Small vendor / commission agent".
Hence, we can remove the latter and assign the former to `vendor`. I believe
we can combine that with the option `Farmer shop owner` in the other column too.

First, we classify employment, and then formalize the profession choices.
```{r}
open_census_ %>%
  mutate(employment_status_clean = 
    case_when(
      str_to_lower(profession) == "not working" ~ "inactive",
      str_to_lower(profession) == "occupation"  ~ "employed",
      str_to_lower(profession) == "too young"   ~ "not applicable",
      TRUE ~ NA_character_

    )
  ) %>%
  mutate(
    profession_clean = case_when(
      str_detect(str_to_lower(profession_choices), "farmer") ~ "farmer",
      str_detect(str_to_lower(profession_choices), "shop owner") ~ "shop owner",
      str_detect(str_to_lower(profession_choices), "teacher") ~ "teacher",
      str_detect(str_to_lower(profession_choices), "student") ~ "student",
      TRUE ~ NA_character_
    )
  ) -> open_census_
```


```{r}
open_census_ %>%
  select(employment_status_clean, profession_clean) %>%
  table()
```


### Sex and Marital Status

This should be a fairly simple one:
```{r}
open_census_ %>%
  select(marital_status) %>%
  table()
```


We can leave it as is.
```{r}
open_census_ %>%
  mutate(marital_status_clean = marital_status %>% str_to_lower() %>% as_factor()) -> open_census_
```


```{r}
open_census_ %>%
  select(sex) %>%
  table()
```


Leave as is:
```{r}
open_census_ %>%
  mutate(sex_clean = sex %>% str_to_lower() %>% as_factor()) -> open_census_
```


### Healthcare Info

This one is a bit more complicated. We have a number of columns for
healthcare.
```{r}
open_census_ %>%
  select(prior_health_care:deathyear) %>%
  mutate(across(everything(), ~ as.factor(.))) %>%
  summary()
```


To be honest, I think that healthcare should be in a separate table in
our outputs. It seems to sparse and complex to be useful in the main table.

So with that, let's summarize what we have so far:

## Pipeline Summary

In this notebook, we have investigated the data and taken the following
steps to harmonize the cohort from the OpenSRP_2018 baseline file "Open Census":

- Cleaned the column names with `janitor`
- Found that `antaravato` is a village in Madagascar represented by the user ID column
- Recognized that the hierarchical units of measure are individual, household, and village
- Therefore, it's important to recognize the difference and significance of the family member name and their
corresponding household head name
- Found the date of birth and cleaned it up with a custom function, estimating the DoB
where there wasn't clear data available.
- Cleaned the education and profession information
- Cleaned Sex and marital status

Here's a visual summary using our `audit_categorical_cleaning` function:
```{r}
open_census_ %>%
  audit_categorical_cleaning(
    raw_col = hh_head_name,
    cleaned_col = hh_head_name_clean,
    var_name = "Household Head Name", plot = FALSE
    )
```


```{r}
open_census_ %>%
  audit_categorical_cleaning(
    raw_col = profession,
    cleaned_col = profession_clean,
    var_name = "Profession", plot = TRUE
    )
```


```{r}
open_census_ %>%
  audit_categorical_cleaning(
    raw_col = education,
    cleaned_col = education_level_clean,
    var_name = "Education", plot = TRUE
    )
```


We can wrap that up in the `preprocess_opensrp2018()` function.

### Generating Unique IDs

As a final step, we're also going to generate the UUID for each
individual. This is important for the final output, as we will
be using this to merge with the other datasets. The previous method
of creating a UUID was to paste a few variables, but this is
not ideal as it can lead to duplicates as well as security issues.
To ensure security, we'll use the `digest` package and a secure [salt](https://en.wikipedia.org/wiki/Salt_(cryptography)).
The salt will be stored in the R environment as a secret variable.
  
  

```{r example-generate_uid}
generate_uid(salt = "cohort_secret", "John", "Doe", "1990-01-01")
```


### Pipeline Step Excution: preprocess_opensrp_2018

The final function will take the Open Census data and run it through
the pipeline we have created.
  
```{r example-preprocess_opensrp2018}
preprocess_opensrp2018(open_census) %>% summary()
```

  





