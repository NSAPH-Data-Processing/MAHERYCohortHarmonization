---
title: "OpenSRP Cohort 2018 Preprocessing"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{OpenSRP Cohort 2018 Preprocessing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r}
library(MAHERYCohortHarmonization)
```

<!-- WARNING - This vignette is generated by {fusen} from dev/flat_preprocess_2018.Rmd: do not edit by hand -->




# preprocess_srp2018

In this notebook, we're exploring and preprocessing the 2018 data from OpenSRP.
The function will ultimately preprocess the data so that it can be harmonized
effectively with the other datasets. Importantly, we use the column suffix `_clean`
to denote that the column has been cleaned and is being kept for analysis.

What is OpenSRP?

What is OpenSRP? It appears OpenSRP should cover year 2018. What is it and what does it survey?
> Open SRP is a software to collect data. We collaborated with an Indonesian-based researchin 2018 that managed and stored our data. Their website does not exist anymore. That is the first platform we used for the ongoing health surveillance surveys. The data is stored in a flat file format.

Load the targets data for prototyping:

The OpenSRP file has a number of sheets:
```{r}
library(here)
library(targets)
tar_load(opensrp, store = here::here("_targets"))
tar_load(opensrp_dict, store = here::here("_targets"))

devtools::load_all()

library(dplyr)
library(stringr)
library(janitor)
library(targets)
library(skimr)
library(forcats)
library(lubridate)
library(googledrive)
library(ggplot2)
library(ggalluvial)
```


Importantly, there are a few "hierarchical levels" of data catalogued here.

Level 0: Household enrollment
Level 1: Individuals in household
Level 2: Antropometric data (every 3 months), dietary intake data collected from head of household (every 4 months), followup data

Although, for clarity, this should be named the opposite...?

Ultimately, a good idea might be to have it such that the most granular
level is an individual, the next level up is their household. But we can solve for that later.

### audit_categorical_cleaning

A function for plotting the mapping of categorical variables from raw to clean, see `audit_categorical_cleaning()`.
    
  
  
  

## Open Census

We're told that the Open census sheet is the baseline. This should be
the most granular level of individual data.
```{r}
open_census <- opensrp$`Open census`
```


```{r}
summary(open_census)
```


```{r}
skimr::skim(open_census)
```


We'll start by using janitor to clean the column names.
```{r}
open_census_ <- janitor::clean_names(open_census)
```


What is user ID?
```{r}
open_census_ %>%
  pull(user_id) %>%
  unique() %>% length()
```


We only have two unique values for this. The values themselves are just a region
in Madagascar. So we can leave this column as a factor.
```{r}
open_census_ %>%
  mutate(user_id_clean = as_factor(user_id)) -> open_census_
```


Next, `hh_head_name`. This is supposedly the name of the head of household.
```{r}
open_census_ %>%
  pull(hh_head_name) %>%
  unique() %>% length()
```


We have 134 unique HHs. But, we can see that there are some
weird anomalies here. For example, some entries have commas and
extra spaces. We can clean this up with `str_squish` and `str_remove_all`.
```{r}
open_census_ %>%
  mutate(hh_head_name_clean = hh_head_name %>%
    str_to_lower() %>%
    str_squish() %>%
    str_remove_all(",")
  ) -> open_census_
```


```{r}
open_census_ %>%
  pull(hh_head_name_clean) %>%
  unique() %>% length()
```


The number of unique entries stays the same, so this is encouraging.

Next, we look at the `name_family_member` column. This is the name of the household member, ideally the most granular observation in the dataset.
```{r}
open_census_ %>%
  pull(name_family_member) %>%
  unique() %>% length()
```


Some must be duplicated, so let's find those:
```{r}
open_census_ %>%
  group_by(name_family_member, hh_head_name) %>%
  summarise(n = n()) %>%
  filter(n > 1) %>%
  arrange(desc(n)) -> dups

open_census_ %>%
  filter(name_family_member %in% dups$name_family_member) %>% arrange(name_family_member) -> multi_names
```


There are a number of people who are listed as the same name, but
with different IDs or member codes.
```{r}
open_census_ %>%
  mutate(name_family_member_clean = name_family_member %>%
    str_to_lower() %>%
    str_squish() %>%
    str_remove_all(",")
  ) -> open_census_
```


This will be dealt with when we create unique IDs below.

### DoB

Next is date of birth. This is coded pretty weird, but we have
a column called `dob_actual` which might tell us if it is a valid
DoB row.

We should check to make sure that everyone has at least one `yes` to this column:
```{r}
open_census_ %>%
  filter(dob_actual == "Yes") %>%
  pull(name_family_member) %>%
  unique() %>% length()
```


So there are some people who do not have a DoB actual.
Let's do our best to form DoBs from the columns anyway, and see
how that goes. Importantly, there are cases where the
month is coded as 'month idr'. Here's a chatgpt response to that:

> This abbreviation may have been derived from “I don’t remember” in English, either directly or influenced by informal bilingual usage, especially in multilingual communities where French and some English are spoken.

I think we can safely assume that this is the case, and
as long as the year is valid, we can make an assumption and place
their DoB as January 1st of that year (we'll flag these though as `dob_estimated`).

Below is the function that makes our DoBs:
  
  
  
Let's see the effect of this mutation:
```{r}
open_census_ %>%
  clean_opencensus_dob() -> open_census_
```


We lose 7 rows in the process. 
```{r}
open_census_ %>%
      filter(is.na(dob_clean))
```


One of them is coded as a leap year in 1997 (impossible). What's interesting is that the `dob_actual` value is "Yes", so this is definitely strange.
Four of them have 999 (NA) as their year, so we can't do anything about that.
The remaining 2 have NA in the month, so we cannot use them.
```{r}
open_census_ %>%
  select(dob_actual, dob_estimated) %>%
  table()
```


There were 54 cases where DoB was estimated but the original column
said that it was actual. I wonder how these got encoded that way then?
```{r}
open_census_ %>%
  filter(dob_actual == "Yes" & dob_estimated == TRUE)
```


What is the distribution of DoB?
```{r}
library(ggplot2)
min_year <- min(open_census_$dob_clean,na.rm = T) %>% year()
max_year <- max(open_census_$dob_clean,na.rm = T) %>% year()
open_census_ %>%
  ggplot(aes(x = dob_clean)) +
  geom_histogram(bins = length(min_year:max_year)) + # one bin per year
  scale_x_date(date_labels = "%Y") +
  ggtitle("Distribution of Date of Birth binned by Year")
```


We can move on with the other variables.

## Open Census — Demographics Cont'd

We can process ethnic group next:
```{r}
open_census_$ethnic_group %>% table()
```


```{r}
open_census_$other_ethnic_group %>% table()
```


I think we can collapse these into a single column.
```{r}
open_census_ %>%
  mutate(ethnicity_clean =
    case_when(
      is.na(ethnic_group)     ~ other_ethnic_group,
      ethnic_group == "Ethnic group other" ~ other_ethnic_group,
      .default = ethnic_group
    ) %>% str_to_lower() %>% as_factor()
  ) -> open_census_
```


```{r}
open_census_$ethnicity %>% table()
```


### Education & Profession

The recoding of education is done like so:
      
    

```{r}
open_census_ %>%
  recode_opensrp_education() -> open_census_
```


```{r}
open_census_$education_level_clean %>% table()
```


I think we can comfortably collapse profession
```{r}
open_census_ %>% 
  select(matches('^profession*')) %>%
  table()
```


We can classify employment with the following:

> “Employment status is classified following ILO and DHIS2 recommendations: distinguishing Employed, Unemployed, Inactive (students, homemakers, retirees, disabled), Not applicable (persons below minimum working age), and Unknown.”

We have a column `other_profession` which currently only only has two
outstanding entries: `commitionaire` and `Zaza loatra tsy miasa`. The latter
means "too young," and the former likely means "Small vendor / commission agent".
Hence, we can remove the latter and assign the former to `vendor`. I believe
we can combine that with the option `Farmer shop owner` in the other column too.

First, we classify employment, and then formalize the profession choices.
```{r}
open_census_ %>%
  mutate(employment_status_clean = 
    case_when(
      str_to_lower(profession) == "not working" ~ "inactive",
      str_to_lower(profession) == "occupation"  ~ "employed",
      str_to_lower(profession) == "too young"   ~ "not applicable",
      TRUE ~ NA_character_

    )
  ) %>%
  mutate(
    profession_clean = case_when(
      str_detect(str_to_lower(profession_choices), "farmer") ~ "farmer",
      str_detect(str_to_lower(profession_choices), "shop owner") ~ "shop owner",
      str_detect(str_to_lower(profession_choices), "teacher") ~ "teacher",
      str_detect(str_to_lower(profession_choices), "student") ~ "student",
      TRUE ~ NA_character_
    )
  ) -> open_census_
```


```{r}
open_census_ %>%
  select(employment_status_clean, profession_clean) %>%
  table()
```


### Sex and Marital Status

This should be a fairly simple one:
```{r}
open_census_ %>%
  select(marital_status) %>%
  table()
```


We can leave it as is.
```{r}
open_census_ %>%
  mutate(marital_status_clean = marital_status %>% str_to_lower() %>% as_factor()) -> open_census_
```


```{r}
open_census_ %>%
  select(sex) %>%
  table()
```


Leave as is:
```{r}
open_census_ %>%
  mutate(sex_clean = sex %>% str_to_lower() %>% as_factor()) -> open_census_
```


### Healthcare Info

This one is a bit more complicated. We have a number of columns for
healthcare.
```{r}
open_census_ %>%
  select(prior_health_care:deathyear) %>%
  mutate(across(everything(), ~ as.factor(.))) %>%
  summary()
```


To be honest, I think that healthcare should be in a separate table in
our outputs. It seems to sparse and complex to be useful in the main table.

So with that, let's summarize what we have so far:

## Pipeline Summary

In this notebook, we have investigated the data and taken the following
steps to harmonize the cohort from the OpenSRP_2018 baseline file "Open Census":

- Cleaned the column names with `janitor`
- Found that `antaravato` is a village in Madagascar represented by the user ID column
- Recognized that the hierarchical units of measure are individual, household, and village
- Therefore, it's important to recognize the difference and significance of the family member name and their
corresponding household head name
- Found the date of birth and cleaned it up with a custom function, estimating the DoB
where there wasn't clear data available.
- Cleaned the education and profession information
- Cleaned Sex and marital status

Here's a visual summary using our `audit_categorical_cleaning` function:
```{r}
open_census_ %>%
  audit_categorical_cleaning(
    raw_col = hh_head_name,
    cleaned_col = hh_head_name_clean,
    var_name = "Household Head Name", plot = FALSE
    )
```


```{r}
open_census_ %>%
  audit_categorical_cleaning(
    raw_col = profession,
    cleaned_col = profession_clean,
    var_name = "Profession", plot = TRUE
    )
```


```{r}
open_census_ %>%
  audit_categorical_cleaning(
    raw_col = education,
    cleaned_col = education_level_clean,
    var_name = "Education", plot = TRUE
    )
```


We can wrap that up in the `preprocess_opensrp2018()` function.

Additionally, we'll include a function to calculate someone's age group:
    
  

### Generating Unique IDs

We're also going to generate the UUID for each
individual. This is important for the final output, as we will
be using this to merge with the other datasets. The previous method
of creating a UUID was to paste a few variables, but this is
not ideal as it can lead to duplicates as well as security issues.
To ensure security, we'll use the `digest` package and a secure [salt](https://en.wikipedia.org/wiki/Salt_(cryptography)).
The salt will be stored in the R environment as a secret variable.
  
  

```{r example-generate_uid}
generate_uid(salt = "cohort_secret", "John", "Doe", "1990-01-01")
```


### Duplicate and Mispelled Names

There is a case where there are two households heads with the same name `Eddy`.
Let's look for more of these:
```{r}
open_census_ %>% 
  group_by(name_family_member_clean, hh_head_name_clean) %>% 
  summarize(n = n()) %>% 
  filter( n > 1)
```


These folks have cases where there are duplicates.

There are also cases where there are mispelled names, or
where the same person is listed with different names:

- Name: be jenore, hh_head_name: be jenole
- Name: juliette, hh_head_name: be juliette
- Name: berthine, hh_head_name: bertine 
- Name: bevita, hh_head_name: bsvita
- Name: jean bemiao hh_head_name: jan bemiao
- Name: jean erique hh_head_name: jean ericque
- Name: marrgelin hh_head_name: margelin
- Name: orelin frasoa hh_head_name: orelin françois
- Name: philippe hh_head_name: phillippe
- Name: raherimanana jean fredo hh_head_name: raherimananajean fredo
- Name: randriamanantena hh_head_name: randriamanantena honorat
- Name: ravalomanana junel hh_head_name: ravalomanana junelle
- Name: jean yves hh_head_name: renaud
- Name: rozadison jean barthelemy hh_head_name: rozaddison jean barthelemy
- Name: tianavelo zara aime hh_head_name: tianavelo
- Name: avoavy clovis hh_head_name: voavy clovis
- Name: zenal ture hh_head_name: zanal ture
- Name: be zela hh_head_name: be zela (duplicate)
- Name: chely (probably married, both same name)
- Name: delore (ditto)
- Name: duplicated eddy

We are only going to need this for examples where we are sure the two individuals are the same.
For those who aren't, we have to filter these out and select the correct one:

1. Be Zela: This individual is likely the head of household; the census
was taken on two separate occasions, but the entries are largely the same.
Importantly, this is the case where we have a birthday with dob_actual = "yes",
but the month is "month idr". However, there are two separate entries for the be zela
household head, so we should keep both.

2. Bilina Victor: Data are identical except for the submission time of the survey,
so we can use one row here.

3. Chely: I'm not sure about these two. They have very similar survey
submission times, but different sexes. I am guessing they are different people,
but do not constitute separate households, since they were literally collected at the
same time. I am tempted to remove this case entirely for the sake of not introducing
noise into the data. For now, I'll keep them separate but make sure to check back
later, and assign anyone with HH head name "Chely" to the same household.

4. Delore: Also separate individuals as Chely

5. Eddy: This is the case where we have two individuals with the same name, but different dates of census and DoBs. We can separate them by date.
    
  
  
```{r example-fix_duplicate_misspelled_names}
#| eval: no

open_census_ %>%
  fix_duplicate_misspelled_names(name_col = name_family_member_clean, 
                                 hh_col = hh_head_name_clean) -> open_census_
```




### Pipeline Step Excution: preprocess_opensrp_2018

The final function will take the Open Census data and run it through
the pipeline we have created.
  
```{r example-preprocess_opensrp2018}
preprocess_opensrp2018(open_census) %>% summary()
```

  





